# MosaicEngine - 矢量游戏引擎方案

## 引擎名称

**MosaicEngine** - 马赛克引擎

寓意：用小方块（像素）拼成丰富的游戏画面，如同马赛克艺术。

## 核心理念

使用纯代码绘制游戏美术资源，而非传统的图片文件。通过Canvas API或其他矢量渲染方式生成游戏画面。

## 当前项目基础

"小葵瓜幸存者"已经实现了纯代码绘制：
- 角色、敌人、Boss都是几何图形拼装
- 技能特效、UI全部代码生成
- 零图片资源，包体约5MB
- 已有可复用模块：Entity、Events、Screen.Manager、Renderer、Input、Audio

## 矢量绘制的优势

| 优势 | 说明 |
|------|------|
| 矢量特性 | 任意缩放不失真，适配各种分辨率 |
| 风格统一 | 所有元素同一套视觉语言 |
| 包体极小 | 纯代码，无资源文件 |
| 动态可控 | 颜色、大小、动画都可参数化 |
| 程序员友好 | 不依赖美术资源 |

## 复杂图形的实现

### Canvas能力
- 基础形状：矩形、圆、椭圆、弧线
- 路径系统：moveTo、lineTo、贝塞尔曲线
- 变换：平移、旋转、缩放
- 渐变、阴影、混合模式

### 贝塞尔曲线填充
理论上可以绘制任意复杂图形。只要路径闭合，不管多复杂的曲线组合都可以填充。

### 实际限制
人脑难以直接编写复杂曲线的控制点坐标，需要可视化工具辅助。

### 解决方案
1. 矢量工具设计（Figma/Illustrator）→ 导出SVG → 提取path数据 → 存成JSON → 运行时用Path2D绑制
2. 自制像素画编辑器 → 导出像素数组数据

## 像素模拟方案

### 核心思路
用Canvas绘制方块模拟像素，本质是"代码实现的像素画"。

### 数据格式
```js
const sprite = {
  width: 16,
  height: 16,
  pixels: [
    '...RRRRR...',
    '..RRRRRRRRR',
    '..BBBxxBx..',
  ],
  palette: { R: '#ff0000', B: '#8B4513', x: '#ffcc99' }
};
```

### 性能优化：预渲染缓存

**阶段1：生成缓存（只做一次）**
```js
const cache = document.createElement('canvas');
cache.width = 24;
cache.height = 24;
const cacheCtx = cache.getContext('2d');

// 绘制像素到缓存
for (let y = 0; y < 24; y++) {
  for (let x = 0; x < 24; x++) {
    cacheCtx.fillStyle = getPixelColor(x, y);
    cacheCtx.fillRect(x, y, 1, 1);
  }
}
```

**阶段2：运行时绘制（每帧）**
```js
// 只需一次drawImage，不是576次fillRect
ctx.drawImage(cache, characterX, characterY);
```

### 动画处理
- 6帧动画 = 预生成6张缓存Canvas
- 运行时只是切换用哪张缓存
- 开销与6张PNG精灵图完全一样

### 性能结论
- 200个角色 × 24×24像素 = 200次drawImage（不是11.5万次fillRect）
- 相同角色类型可共享缓存
- 运行时性能与传统图片方案一致

## 数据存储与包体对比

### PNG vs 像素数组（24×24像素）

| 场景 | PNG | 像素数组 |
|------|-----|----------|
| 简单图形（大色块） | 200-400B | 100-300B（RLE更小）|
| 复杂图形（多细节） | 500-1KB | 500-600B |
| 大量透明区域 | 压缩有限 | 稀疏存储优势大 |

### 稀疏存储优化

只记录有颜色的像素，跳过透明区域：

```js
// 完整存储：576个像素点
// 稀疏存储：只存有内容的像素（可能只有100-200个）

const sprite = {
  width: 24,
  height: 24,
  pixels: [
    { x: 5, y: 0, c: 'R' },
    { x: 6, y: 0, c: 'R' },
    // ... 只存有颜色的像素
  ],
  palette: { R: '#ff0000' }
};

// 更紧凑的字符串格式
"5,0,R;6,0,R;7,0,R..."
```

**效果：** 透明区域多的角色纹理，数据量可减少60-80%，甚至比PNG更小。

### 其他压缩方案

- **行程编码(RLE)**：连续同色像素合并，如 `R3B5` 表示3个R、5个B
- **索引+调色板**：每像素4bit（16色），数据量减半
- **分块存储**：将图像分成8×8块，空块直接跳过

## 外部资源导入

可以读取PNG图片像素数据，转成自定义格式：
```js
ctx.drawImage(img, 0, 0);
const imageData = ctx.getImageData(0, 0, img.width, img.height);
// imageData.data 是 RGBA 数组
```

## 平台支持

### Web浏览器
- Canvas 2D，现代浏览器GPU加速
- 当前方案直接可用

### 微信小程序
- 需要适配层（weapp-adapter）
- DOM UI需改为Canvas UI
- localStorage → wx.setStorageSync
- 触摸事件适配

### 桌面编辑器（C# IMGUI）
嵌入方案：
1. **WebView2** - 用系统Edge内核，仅Windows，包体小
2. **CefSharp** - Chromium嵌入，跨平台，包体大
3. **SkiaSharp** - C#的Skia绑定，自己实现Canvas API子集

推荐：编辑器UI用IMGUI，游戏预览窗口嵌入WebView2/CefSharp

## 高性能矢量渲染备选

| 方案 | 说明 |
|------|------|
| WebGL + 实例化渲染 | 大量相同形状，一次draw call |
| SkiaSharp | C#下的高性能2D矢量库 |
| NanoVG | 轻量级，基于OpenGL |
| Blend2D | JIT编译渲染管线，极高性能 |

## 编辑器方案

### 技术选型：全栈JavaScript

放弃C# IMGUI方案，改用JS统一编辑器和游戏运行时：
- 引擎代码共用
- 编辑器里直接预览游戏
- 不需要跨语言通信

### 编辑器框架：Electron

- 跨平台（Windows/Mac/Linux）
- VS Code、Discord同款技术
- 编辑器包体约100MB（开发者用，可接受）
- 支持多窗口（主编辑器、像素编辑器、游戏预览可独立窗口）
- 多显示器支持
- 窗口间通过IPC通信共享数据

### 游戏发布包体

| 平台 | 技术 | 包体大小 |
|------|------|----------|
| Web | 纯JS/HTML | 几MB |
| 微信小游戏 | 纯JS | 几MB |
| 桌面版（可选） | Tauri包装 | 10-20MB |

**游戏不包含Electron**，就像Unity编辑器几GB但导出的Web游戏只有几MB。

### 备选：Tauri

如果追求更小的编辑器包体：
- 前端JS，后端Rust
- 编辑器包体10-20MB
- 学习成本稍高

### 备选：纯Web编辑器

- 浏览器直接打开使用
- 零安装
- 文件操作受限（需手动上传/下载）
- 适合轻量工具（像素画编辑器等）

## 引擎架构规划

```
engine/
  core/       # Entity, Events, GameLoop
  render/     # Canvas渲染器、缓存管理
  ui/         # Canvas UI组件
  input/      # 输入抽象
  audio/      # 音频抽象
  platform/   # 平台适配 (web, weapp)
  assets/     # 像素/矢量资源加载器

tools/
  pixel-editor/   # 像素画编辑器
  vector-editor/  # 矢量图形编辑器
  
games/
  kuigua-survivor/  # 当前游戏
  next-game/        # 下一个游戏
```

## 实施建议

### 第一步：完善游戏引擎核心（纯JS/Web）
- 完善当前游戏架构
- 抽象可复用引擎层
- 做几个小游戏验证

### 第二步：做轻量工具（Web版）
- 像素画编辑器
- 关卡编辑器
- 数据配置工具

### 第三步：桌面编辑器整合
- 用C# IMGUI做编辑器框架
- 嵌入WebView做游戏预览
- 整合各工具

## 结论

**方案完全可行。**

核心优化点是"预渲染缓存"，将代码绘制的开销从运行时转移到初始化阶段，运行时性能与传统图片方案一致。

这是一个小众但有价值的方向，适合：
- 独立开发者
- Game Jam
- 教学场景
- 追求极小包体的项目
